<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>JiBaJiBa v4.3 优化版（更新）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
:root{
    --bg-dark:#0f0f0f;
    --bg-card:#1b1b1b;
    --bg-hover:#2b2b2b;
    --text-main:#f1f1f1;
    --text-sub:#aaaaaa;
    --accent:#00a1d6;
}
*{box-sizing:border-box}
body{
    margin:0;padding:15px;
    background:var(--bg-dark);
    color:var(--text-main);
    font-family:"Segoe UI",sans-serif;
}
.container{display:flex;align-items:center;margin-bottom:12px;flex-wrap:wrap;gap:10px}
.title_{display:flex;align-items:center;font-size:26px;font-weight:bold}
.title_ img{
    height:38px;margin-right:10px;border-radius:8px;
    transition:transform 0.2s ease;
}
.title_ img:hover{transform:scale(1.15);cursor:pointer}

/* top controls */
.protocols{display:flex;gap:6px;flex-wrap:wrap}
.protocol-btn{padding:6px 12px;border-radius:6px;border:none;cursor:pointer;background:var(--bg-card);color:var(--text-main);transition:0.18s}
.protocol-btn.active{background:var(--accent);color:#fff}
.protocol-btn:hover{background:var(--bg-hover)}

.search_{display:flex;flex:1;min-width:200px}
.text_enter{flex:1;background:var(--bg-card);border:1px solid var(--bg-hover);border-radius:6px;padding:8px;color:var(--text-main)}
.button_s{margin-left:10px;padding:8px 14px;border-radius:6px;border:none;background:var(--accent);color:#fff;cursor:pointer;transition:0.18s}
.button_s:hover{background:#33b6e8}

/* main layout */
.main_{display:flex;gap:18px;margin-top:18px;height:calc(100vh - 80px);flex-wrap:wrap}
.videoContainer{flex:3;min-width:300px;background:var(--bg-card);border-radius:10px;padding:12px;box-shadow:0 0 12px rgba(0,0,0,0.35);display:flex;flex-direction:column}
video{width:100%;flex:1;border-radius:10px;background:#000}
.status{margin-top:6px;font-size:13px;color:var(--text-sub)}
.controls{margin-top:10px;display:flex;gap:6px;flex-wrap:wrap}
.button_l,.button_r{height:30px;padding:0 12px;border-radius:6px;border:none;cursor:pointer;font-size:12px;transition:transform 0.12s, box-shadow 0.12s, background 0.12s}
.button_l{background:var(--bg-hover);color:var(--text-main)}
.button_r{background:var(--accent);color:white}
.button_l:hover,.button_r:hover{background:#33b6e8;transform:translateY(-1px);box-shadow:0 2px 6px rgba(0,0,0,0.28)}

/* side list */
.buttons{flex:1;min-width:220px;display:flex;flex-direction:column;overflow-y:auto;max-height:100%}
.section-title{font-size:14px;color:var(--text-main);margin:10px 0 4px 0;font-weight:bold;padding-left:6px}

/* channel button */
.button_play{
    display:flex;align-items:center;background:var(--bg-card);border:none;border-radius:10px;padding:10px;margin-bottom:6px;
    color:var(--text-main);cursor:pointer;transition:background 0.2s,transform 0.15s,box-shadow 0.15s;
    height:60px;width:100%;position:relative;overflow:hidden;
}
.button_play.manual{height:45px}
.button_play:hover{background:var(--bg-hover);transform:translateY(-2px);box-shadow:0 6px 18px rgba(0,0,0,0.45)}
.button_play:active{transform:translateY(0);box-shadow:0 2px 6px rgba(0,0,0,0.3)}

.head_img{width:48px;height:48px;border-radius:50%;margin-right:10px;object-fit:cover}

.channel_text{font-size:14px}
.url_text{font-size:11px;color:var(--text-sub);word-break:break-all;margin-left:58px;margin-top:4px}

/* delete */
.delete_btn{position:absolute;right:8px;top:50%;transform:translateY(-50%);background:none;border:none;color:var(--text-main);font-weight:bold;cursor:pointer;font-size:18px;transition:color 0.12s,transform 0.12s}
.delete_btn:hover{color:#ff4d4d;transform:scale(1.2)}

/* fullscreen overlay */
.fullscreen-mode{
    position:fixed;top:0;left:0;width:100vw;height:100vh;background:black;z-index:9999;display:flex;flex-direction:column;justify-content:center;align-items:center;
}
.fullscreen-mode video{width:100%;height:100%;object-fit:contain}
.fullscreen-controls{
    position:absolute;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);padding:10px;border-radius:5px;z-index:10000;opacity:1;transition:opacity 0.25s;
}
.fullscreen-controls.hidden{opacity:0;pointer-events:none}
.fullscreen-controls button{margin:0 5px;color:white;background:var(--bg-hover);border:none;padding:8px 15px;border-radius:3px;cursor:pointer;transition:0.12s}
.fullscreen-controls button:hover{background:var(--bg-card)}

/* pressed class for JS click feedback (optional) */
.pressed{transform:translateY(0) scale(0.995);box-shadow:0 1px 4px rgba(0,0,0,0.25)}

/* responsive: hide fullscreen button on small screens */
@media (max-width:800px){
    .main_{flex-direction:column}
    .videoContainer{height:300px}
    /* 隐藏网页全屏按钮（手机端） */
    #fullscreenBtn{display:none}
}
</style>
</head>
<body>

<div class="container">
    <div class="title_"><img src="icon.png" alt="logo">JiBaJiBa</div>

    <div class="protocols" role="tablist" aria-label="协议选择">
        <button class="protocol-btn active" data-proto="whep" aria-pressed="true">WHEP</button>
        <button class="protocol-btn" data-proto="whip">WHIP</button>
        <button class="protocol-btn" data-proto="rtmp">RTMP</button>
    </div>

    <div class="search_">
        <input id="roomInput" type="text" placeholder="输入房间号" class="text_enter" aria-label="房间号">
        <button class="button_s" id="connectBtn">连接</button>
    </div>
</div>

<div class="main_">
    <div class="videoContainer" aria-live="polite">
        <video id="remoteVideo" autoplay playsinline muted controls></video>
        <div id="status" class="status">未连接</div>
        <div class="controls" role="toolbar">
            <button class="button_l" id="refreshBtn">刷新</button>
            <button class="button_l" id="disconnectBtn">断开</button>
            <button class="button_l" id="fullscreenBtn">网页全屏</button>
        </div>
    </div>

    <div class="buttons" id="channelList">
        <div class="section-title">预设频道</div>
        <div id="presetContainer" aria-label="预设频道"></div>

        <div class="section-title">历史记录</div>
        <div id="historyContainer" aria-label="历史记录"></div>
    </div>
</div>

<script src="adapter.js"></script>
<script>
/**
 * JiBaJiBaPlayer - 封装版
 * 特性：
 *  - 预设频道、历史记录（可删除）
 *  - 协议选择（WHEP/WHIP/RTMP）
 *  - Enter 键连接
 *  - 动效（CSS）与按下反馈（JS）
 *  - 手机端隐藏全屏按钮（通过 CSS 媒体查询）
 */
class JiBaJiBaPlayer {
    constructor(){
        this.pc = null;
        this.currentUrl = null;
        this.statsInterval = null;
        this.isFullscreen = false;
        this.fullscreenTimeout = null;
        this.currentProto = 'whep';

        this.video = document.getElementById('remoteVideo');
        this.statusEl = document.getElementById('status');
        this.fullscreenBtn = document.getElementById('fullscreenBtn');
        this.roomInput = document.getElementById('roomInput');
        this.presetContainer = document.getElementById('presetContainer');
        this.historyContainer = document.getElementById('historyContainer');

        this.presetChannels = [
            { name: '[直播] JOYG', img: 'joyg.jpg', url: 'http://10.126.126.10:1985/rtc/v1/whep/?app=live&stream=JOYG' },
            { name: '[直播] 超级老鼠', img: 'cmhh.jpg', url: 'http://10.126.126.10:1985/rtc/v1/whep/?app=live&stream=CMHH' },
            { name: '[直播] Pure1ove', img: 'pl.jpg', url: 'http://10.126.126.10:1985/rtc/v1/whep/?app=live&stream=PL' }
        ];

        this._bindUI();
        this._loadPresetChannels();
        this.updateStatus('就绪 - 点击频道或输入房间号开始播放');
    }

    _bindUI(){
        // protocol buttons
        document.querySelectorAll('.protocol-btn').forEach(btn=>{
            btn.addEventListener('click', ()=>{
                document.querySelectorAll('.protocol-btn').forEach(b=>b.classList.remove('active'));
                document.querySelectorAll('.protocol-btn').forEach(b=>b.setAttribute('aria-pressed','false'));
                btn.classList.add('active');
                btn.setAttribute('aria-pressed','true');
                this.currentProto = btn.dataset.proto;
            });
        });

        document.getElementById('connectBtn').addEventListener('click', ()=>this.connectRoom());
        document.getElementById('refreshBtn').addEventListener('click', ()=>this.refresh());
        document.getElementById('disconnectBtn').addEventListener('click', ()=>this.disconnect());
        if(this.fullscreenBtn) this.fullscreenBtn.addEventListener('click', ()=>this.toggleFullscreen());

        // Enter 键连接
        this.roomInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') this.connectRoom(); });

        // 全局快捷键
        document.addEventListener('keydown', (e)=>{
            if((e.key === 'f' || e.key === 'F') && !this.isFullscreen && this.video.srcObject) this.toggleFullscreen();
            if(e.key === 'Escape' && this.isFullscreen) this.toggleFullscreen();
        });
    }

    _loadPresetChannels(){
        this.presetContainer.innerHTML = '';
        this.presetChannels.forEach(ch=>{
            const btn = this._createChannelButton(ch.name, ch.img, ch.url, false);
            this.presetContainer.appendChild(btn);
        });
    }

    /**
     * 创建频道按钮
     * manual=true 时会把按钮 & url 文本加入历史记录区并附带删除按钮
     */
    _createChannelButton(name, img, url, manual=false){
        const btn = document.createElement('button');
        btn.className = 'button_play' + (manual ? ' manual' : '');
        btn.type = 'button';
        // click connect
        btn.addEventListener('click', ()=> this.connectStream(url));
        // press feedback (adds/removes pressed class briefly)
        btn.addEventListener('mousedown', ()=> btn.classList.add('pressed'));
        document.addEventListener('mouseup', ()=> btn.classList.remove('pressed'));
        btn.addEventListener('mouseleave', ()=> btn.classList.remove('pressed'));

        if(img){
            const imgEl = document.createElement('img');
            imgEl.className = 'head_img';
            imgEl.src = img;
            imgEl.alt = '';
            btn.appendChild(imgEl);
        }

        const txt = document.createElement('div');
        txt.className = 'channel_text';
        txt.innerText = name;
        btn.appendChild(txt);

        if(manual){
            // url text element must be created before delete handler so it exists in scope
            const urlDiv = document.createElement('div');
            urlDiv.className = 'url_text';
            urlDiv.innerText = url;

            const delBtn = document.createElement('button');
            delBtn.className = 'delete_btn';
            delBtn.type = 'button';
            delBtn.title = '删除记录';
            delBtn.innerText = '×';
            delBtn.addEventListener('click', (e)=>{
                e.stopPropagation();
                // remove both elements (button and its url text)
                if(btn.parentElement) btn.parentElement.removeChild(btn);
                if(urlDiv.parentElement) urlDiv.parentElement.removeChild(urlDiv);
            });

            btn.appendChild(delBtn);

            // append into history container (url under the button for clarity)
            this.historyContainer.appendChild(btn);
            this.historyContainer.appendChild(urlDiv);
        }

        return btn;
    }

    generateUrl(room){
        if(!room) return null;
        switch(this.currentProto){
            case 'whep': return `http://10.126.126.10:1985/rtc/v1/whep/?app=live&stream=${room}`;
            case 'whip': return `http://10.126.126.10:1985/rtc/v1/whip/?app=live&stream=${room}`;
            case 'rtmp': return `rtmp://10.126.126.10/live/${room}`;
            default: return null;
        }
    }

    connectRoom(){
        const room = this.roomInput.value.trim();
        if(!room) return;
        const url = this.generateUrl(room);
        if(!url) return;
        this.connectStream(url);
        this.addManualChannel(room, url);
    }

    addManualChannel(name, url){
        // create and append history entry
        this._createChannelButton(name, null, url, true);
    }

    refresh(){
        if(this.currentUrl) this.connectStream(this.currentUrl);
    }

    disconnect(){
        if(this.pc){ try{ this.pc.close(); }catch(e){} this.pc = null; }
        if(this.statsInterval){ clearInterval(this.statsInterval); this.statsInterval = null; }
        try{ this.video.srcObject = null; }catch(e){}
        this.updateStatus('已断开连接');
        window._lastBytes = 0;
        if(this.isFullscreen) this.toggleFullscreen();
    }

    async connectStream(url){
        // disconnect any existing
        this.disconnect();
        this.currentUrl = url;
        this.updateStatus('正在连接...');
        try{
            this.pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            this.pc.addTransceiver('video', { direction: 'recvonly' });
            this.pc.addTransceiver('audio', { direction: 'recvonly' });

            this.pc.ontrack = (e)=>{
                try{ this.video.srcObject = e.streams[0]; }catch(err){}
                this.updateStatus('连接成功 · 正在接收视频');
            };

            // optional: ICE state feedback
            this.pc.oniceconnectionstatechange = ()=> {
                if(this.pc) {
                    const st = this.pc.iceConnectionState;
                    if(st === 'failed' || st === 'disconnected') this.updateStatus(`ICE: ${st}`);
                }
            };

            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);

            // POST offer.sdp to server (WHEP / WHIP endpoint)
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/sdp' },
                body: offer.sdp
            });

            if(!response.ok) throw new Error(`HTTP ${response.status}`);
            const answer = await response.text();
            await this.pc.setRemoteDescription({ type: 'answer', sdp: answer });

            this._startStats();
        }catch(e){
            console.error('连接失败', e);
            this.updateStatus(`连接失败: ${e.message}`);
            this.disconnect();
        }
    }

    _startStats(){
        if(this.statsInterval) clearInterval(this.statsInterval);
        this.statsInterval = setInterval(async ()=>{
            if(!this.pc || this.pc.connectionState !== 'connected') return;
            try{
                const stats = await this.pc.getStats();
                let fps = 0, bitrate = 0, rtt = 0, loss = 0;
                stats.forEach(r=>{
                    if(r.type === 'inbound-rtp' && r.kind === 'video'){
                        if(r.framesPerSecond) fps = r.framesPerSecond;
                        if(r.bytesReceived && r.timestamp){
                            if(!window._lastBytes) window._lastBytes = r.bytesReceived;
                            const dt = (r.timestamp - (window._lastTimestamp || r.timestamp)) / 1000;
                            if(dt > 0) bitrate = ((r.bytesReceived - window._lastBytes) * 8 / dt / 1024 / 1024).toFixed(2);
                            window._lastBytes = r.bytesReceived; window._lastTimestamp = r.timestamp;
                        }
                        if(r.packetsLost !== undefined && r.packetsReceived !== undefined){
                            const total = r.packetsLost + r.packetsReceived;
                            loss = total > 0 ? (r.packetsLost / total * 100).toFixed(2) : 0;
                        }
                    }
                    if(r.type === 'candidate-pair' && r.currentRoundTripTime) rtt = (r.currentRoundTripTime * 1000).toFixed(0);
                });
                this.updateStatus(`延迟: ${rtt}ms | 码率: ${bitrate}Mbps | FPS: ${fps} | 丢包率: ${loss}%`);
            }catch(e){
                // quietly ignore
                // console.error('获取统计失败', e);
            }
        }, 1000);
    }

    toggleFullscreen(){
        // if fullscreen is hidden by CSS (mobile), this button won't be visible/clickable,
        // but the method remains safe to call (no-op on small screens if desired)
        if(!this.isFullscreen){
            // create overlay
            const overlay = document.createElement('div');
            overlay.className = 'fullscreen-mode';
            overlay.id = 'fullscreenContainer';

            // control bar
            const controls = document.createElement('div');
            controls.className = 'fullscreen-controls';
            controls.innerHTML = `<button id="fsDisconnectBtn" type="button">断开</button><button id="fsExitBtn" type="button">退出全屏</button>`;

            // clone video to overlay to avoid moving original node (safer cross-browser)
            const videoClone = this.video.cloneNode(true);
            videoClone.controls = true;
            // copy srcObject if any
            try{ if(this.video.srcObject) videoClone.srcObject = this.video.srcObject; }catch(e){}

            overlay.appendChild(videoClone);
            overlay.appendChild(controls);
            document.body.appendChild(overlay);

            // hook buttons
            document.getElementById('fsDisconnectBtn').addEventListener('click', ()=> this.disconnect());
            document.getElementById('fsExitBtn').addEventListener('click', ()=> this.toggleFullscreen());

            // hide original video (keeps layout)
            this.video.style.display = 'none';
            if(this.fullscreenBtn) this.fullscreenBtn.textContent = '退出全屏';
            this.isFullscreen = true;

            // hide controls after short delay, show on mousemove
            this.fullscreenTimeout = setTimeout(()=> controls.classList.add('hidden'), 1000);
            overlay.addEventListener('mousemove', ()=>{
                controls.classList.remove('hidden');
                clearTimeout(this.fullscreenTimeout);
                this.fullscreenTimeout = setTimeout(()=> controls.classList.add('hidden'), 1200);
            });
            controls.addEventListener('mouseleave', ()=> {
                clearTimeout(this.fullscreenTimeout);
                this.fullscreenTimeout = setTimeout(()=> controls.classList.add('hidden'), 1200);
            });
        }else{
            const overlay = document.getElementById('fullscreenContainer');
            if(overlay) document.body.removeChild(overlay);
            if(this.fullscreenTimeout) { clearTimeout(this.fullscreenTimeout); this.fullscreenTimeout = null; }
            this.video.style.display = 'block';
            if(this.fullscreenBtn) this.fullscreenBtn.textContent = '网页全屏';
            this.isFullscreen = false;
        }
    }

    updateStatus(text){ if(this.statusEl) this.statusEl.innerText = text; }
}

// create global instance
window.player = new JiBaJiBaPlayer();
</script>
</body>
</html>
