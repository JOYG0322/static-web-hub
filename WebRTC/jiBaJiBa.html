<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>JiBaJiBa v4.3 优化版（更新）</title>
    <link rel="icon" type="image/png" href="../assets/icon.png">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        :root {
            --bg-dark: #1a1a1a;
            --bg-card: #2c2c2c;
            --bg-hover: #3e3e3e;
            --text-main: #e0e0e0;
            --text-sub: #cccccc;
            --accent: #00a1d6;
        }
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 15px;
            background: var(--bg-dark);
            color: var(--text-main);
            font-family: "Segoe UI", sans-serif;
        }
        .container { display: flex; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
        .title_ { display: flex; align-items: center; font-size: 26px; font-weight: bold; }
        .title_ img { height: 38px; margin-right: 10px; border-radius: 8px; transition: transform 0.2s ease; }
        .title_ img:hover { transform: scale(1.15); cursor: pointer; }
        .protocols { display: flex; gap: 6px; flex-wrap: wrap; }
        .protocol-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            background: var(--bg-card);
            color: var(--text-main);
            transition: 0.18s;
        }
        .protocol-btn.active { background: var(--accent); color: #fff; }
        .protocol-btn:hover { background: var(--bg-hover); }
        .search_ { display: flex; flex: 1; min-width: 200px; }
        .text_enter {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--bg-hover);
            border-radius: 6px;
            padding: 8px;
            color: var(--text-main);
        }
        .button_s {
            margin-left: 10px;
            padding: 8px 14px;
            border-radius: 6px;
            border: none;
            background: var(--accent);
            color: #fff;
            cursor: pointer;
            transition: 0.18s;
        }
        .button_s:hover { background: #33b6e8; }
        .main_ {
            display: flex;
            gap: 18px;
            margin-top: 18px;
            height: calc(100vh - 80px);
            flex-wrap: wrap;
        }
        .videoContainer {
            flex: 3;
            min-width: 300px;
            background: var(--bg-card);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 0 12px rgba(0,0,0,0.35);
            display: flex;
            flex-direction: column;
        }
        video { width: 100%; flex: 1; border-radius: 10px; background: #000; }
        .status { margin-top: 6px; font-size: 13px; color: var(--text-sub); }
        .controls { margin-top: 10px; display: flex; gap: 6px; flex-wrap: wrap; }
        .button_l, .button_r {
            height: 30px;
            padding: 0 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            transition: transform 0.12s, box-shadow 0.12s, background 0.12s;
        }
        .button_l { background: var(--bg-hover); color: var(--text-main); }
        .button_r { background: var(--accent); color: white; }
        .button_l:hover, .button_r:hover {
            background: #33b6e8;
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.28);
        }
        .buttons {
            flex: 1;
            min-width: 220px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            max-height: 100%;
        }
        .section-title {
            font-size: 14px;
            color: var(--text-main);
            margin: 10px 0 4px 0;
            font-weight: bold;
            padding-left: 6px;
        }
        .button_play {
            display: flex;
            align-items: center;
            background: var(--bg-card);
            border: none;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 6px;
            color: var(--text-main);
            cursor: pointer;
            transition: background 0.2s, transform 0.15s, box-shadow 0.15s;
            height: 60px;
            width: 100%;
            position: relative;
            overflow: hidden;
        }
        .button_play.manual { height: 45px; }
        .button_play:hover {
            background: var(--bg-hover);
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(0,0,0,0.45);
        }
        .button_play:active { transform: translateY(0); box-shadow: 0 2px 6px rgba(0,0,0,0.3); }
        .head_img { width: 48px; height: 48px; border-radius: 50%; margin-right: 10px; object-fit: cover; }
        .channel_text { font-size: 14px; }
        .url_text {
            font-size: 11px;
            color: var(--text-sub);
            word-break: break-all;
            margin-left: 58px;
            margin-top: 4px;
        }
        .delete_btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-main);
            font-weight: bold;
            cursor: pointer;
            font-size: 18px;
            transition: color 0.12s, transform 0.12s;
        }
        .delete_btn:hover { color: #ff4d4d; transform: scale(1.2); }
        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: black;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .fullscreen-mode video { width: 100%; height: 100%; object-fit: contain; }
        .fullscreen-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.25s;
        }
        .fullscreen-controls.hidden { opacity: 0; pointer-events: none; }
        .fullscreen-controls button {
            margin: 0 5px;
            color: white;
            background: var(--bg-hover);
            border: none;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            transition: 0.12s;
        }
        .fullscreen-controls button:hover { background: var(--bg-card); }
        .pressed { transform: translateY(0) scale(0.995); box-shadow: 0 1px 4px rgba(0,0,0,0.25); }
        @media (max-width: 800px) {
            .main_ { flex-direction: column; }
            .videoContainer { height: 300px; }
            #fullscreenBtn { display: none; }
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }
        .modal-overlay.active { opacity: 1; visibility: visible; }
        .modal-box {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            min-width: 320px;
            max-width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.2s;
        }
        .modal-overlay.active .modal-box { transform: scale(1); }
        .modal-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 16px;
            color: var(--text-main);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: var(--text-sub);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .modal-close:hover { color: #ff4d4d; }
        .modal-row {
            display: flex;
            align-items: center;
            margin-bottom: 14px;
        }
        .modal-label {
            flex: 1;
            font-size: 14px;
            color: var(--text-main);
        }
        .modal-input {
            width: 100px;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--bg-hover);
            background: var(--bg-dark);
            color: var(--text-main);
            font-size: 14px;
            text-align: right;
        }
        .modal-input:focus { outline: none; border-color: var(--accent); }
        .modal-hint {
            font-size: 12px;
            color: var(--text-sub);
            margin-left: 8px;
        }
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        .modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: 0.15s;
        }
        .modal-btn-cancel { background: var(--bg-hover); color: var(--text-main); }
        .modal-btn-save { background: var(--accent); color: #fff; }
        .modal-btn:hover { opacity: 0.85; }
    </style>
</head>
<body>
    <div class="container">
        <div class="title_"><img src="../assets/icon.png" alt="logo">JiBaJiBa</div>
        <div class="protocols" role="tablist" aria-label="协议选择">
            <button class="protocol-btn active" data-proto="whep" aria-pressed="true" onclick="location.href='http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=JOYG'">WHEP</button>
            <button class="protocol-btn" data-proto="hls" aria-pressed="false" onclick="location.href='http://localhost:8080/live/room.m3u8'">HLS</button>
        </div>
        <div class="search_">
            <input id="roomInput" type="text" placeholder="输入房间号" class="text_enter" aria-label="房间号">
            <button class="button_s" id="connectBtn">连接</button>
        </div>
    </div>

    <div class="main_">
        <div class="videoContainer" aria-live="polite">
            <video id="remoteVideo" autoplay playsinline muted controls></video>
            <div id="status" class="status">未连接</div>
            <div class="controls" role="toolbar">
                <button class="button_l" id="refreshBtn">刷新</button>
                <button class="button_l" id="disconnectBtn">断开</button>
                <button class="button_l" id="fullscreenBtn">网页全屏</button>
                <button class="button_l" id="reconnectConfigBtn">自动重连配置</button>
            </div>
        </div>

        <div class="buttons" id="channelList">
            <div class="section-title">预设频道</div>
            <div id="presetContainer" aria-label="预设频道"></div>
            <div class="section-title">历史记录</div>
            <div id="historyContainer" aria-label="历史记录"></div>
        </div>
    </div>

    <script src="adapter.js"></script>
    <script>
        class JiBaJiBaPlayer {
            constructor() {
                this.pc = null;
                this.currentUrl = null;
                this.statsInterval = null;
                this.isFullscreen = false;
                this.fullscreenTimeout = null;
                this.currentProto = 'whep';

                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
                this.maxReconnectDelay = 30000;
                this.reconnectTimer = null;
                this.isManualDisconnect = false;
                this.isConnected = false;

                this.video = document.getElementById('remoteVideo');
                this.statusEl = document.getElementById('status');
                this.fullscreenBtn = document.getElementById('fullscreenBtn');
                this.roomInput = document.getElementById('roomInput');
                this.presetContainer = document.getElementById('presetContainer');
                this.historyContainer = document.getElementById('historyContainer');

                this.presetChannels = [
                    { name: '[直播] JOYG', img: '../assets/joyg.jpg', url: 'http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=JOYG' },
                    { name: '[直播] CMHH', img: '../assets/cmhh.jpg', url: 'http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=CMHH' },
                    { name: '[直播] Pure1ove', img: '../assets/pl.jpg', url: 'http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=PL' },
                    { name: '[直播] DJ_Hero', img: '../assets/ljy.jpg', url: 'http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=LJY' },
                    { name: '[直播] REDguard', img: '../assets/aaa.jpg', url: 'http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=AAA' }
                ];

                this._bindUI();
                this._loadPresetChannels();
                this.updateStatus('就绪 - 点击频道或输入房间号开始播放');
            }

            _bindUI() {
                document.querySelectorAll('.protocol-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.protocol-btn').forEach(b => {
                            b.classList.remove('active');
                            b.setAttribute('aria-pressed', 'false');
                        });
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                        this.currentProto = btn.dataset.proto;
                    });
                });

                document.getElementById('connectBtn').addEventListener('click', () => this.connectRoom());
                document.getElementById('refreshBtn').addEventListener('click', () => this.refresh());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                if (this.fullscreenBtn) this.fullscreenBtn.addEventListener('click', () => this.toggleFullscreen());

                const reconnectConfigBtn = document.getElementById('reconnectConfigBtn');
                if (reconnectConfigBtn) reconnectConfigBtn.addEventListener('click', () => this.openReconnectModal());

                this.roomInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') this.connectRoom(); });

                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    switch (e.key) {
                        case 'f': case 'F':
                            if (!this.isFullscreen && (this.video.srcObject || this.video.src)) this.toggleFullscreen();
                            break;
                        case 'Escape':
                            if (this.isFullscreen) this.toggleFullscreen();
                            break;
                        case 's': case 'S':
                            this.refresh();
                            break;
                        case 'd': case 'D':
                            this.disconnect();
                            break;
                        case '1':
                            if (this.presetChannels[0]) this.connectStream(this.presetChannels[0].url, 'whep');
                            break;
                        case '2':
                            if (this.presetChannels[1]) this.connectStream(this.presetChannels[1].url, 'whep');
                            break;
                        case '3':
                            if (this.presetChannels[2]) this.connectStream(this.presetChannels[2].url, 'whep');
                            break;
                    }
                });
            }

            _loadPresetChannels() {
                this.presetContainer.innerHTML = '';
                this.presetChannels.forEach((ch, index) => {
                    const btn = this._createChannelButton(ch.name, ch.img, ch.url, false, 'whep');
                    btn.setAttribute('data-hotkey', index + 1);
                    this.presetContainer.appendChild(btn);
                });
            }

            _createChannelButton(name, img, url, manual = false, proto = 'whep') {
                const btn = document.createElement('button');
                btn.className = 'button_play' + (manual ? ' manual' : '');
                btn.type = 'button';
                btn.addEventListener('click', () => this.connectStream(url, proto));
                btn.addEventListener('mousedown', () => btn.classList.add('pressed'));
                document.addEventListener('mouseup', () => btn.classList.remove('pressed'));
                btn.addEventListener('mouseleave', () => btn.classList.remove('pressed'));

                if (img) {
                    const imgEl = document.createElement('img');
                    imgEl.className = 'head_img';
                    imgEl.src = img;
                    imgEl.alt = '';
                    btn.appendChild(imgEl);
                }

                const txt = document.createElement('div');
                txt.className = 'channel_text';
                txt.innerText = name;
                btn.appendChild(txt);

                if (manual) {
                    const urlDiv = document.createElement('div');
                    urlDiv.className = 'url_text';
                    urlDiv.innerText = url;

                    const delBtn = document.createElement('button');
                    delBtn.className = 'delete_btn';
                    delBtn.type = 'button';
                    delBtn.title = '删除记录';
                    delBtn.innerText = '×';
                    delBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (btn.parentElement) btn.parentElement.removeChild(btn);
                        if (urlDiv.parentElement) urlDiv.parentElement.removeChild(urlDiv);
                    });

                    btn.appendChild(delBtn);
                    this.historyContainer.appendChild(btn);
                    this.historyContainer.appendChild(urlDiv);
                }

                return btn;
            }

            generateUrl(room) {
                if (!room) return null;
                switch (this.currentProto) {
                    case 'whep':
                        return `http://10.126.126.15:1985/rtc/v1/whep/?app=live&stream=${room}`;
                    case 'hls':
                        return `http://localhost:8080/live/${room}.m3u8`;
                    default:
                        return null;
                }
            }

            connectRoom() {
                const room = this.roomInput.value.trim();
                if (!room) return;
                const url = this.generateUrl(room);
                if (!url) return;
                this.connectStream(url, this.currentProto);
                this.addManualChannel(room, url, this.currentProto);
            }

            addManualChannel(name, url, proto) {
                this._createChannelButton(name, null, url, true, proto);
            }

            refresh() {
                if (this.currentUrl) this.connectStream(this.currentUrl, this.currentProto);
            }

            disconnect() {
                this.isManualDisconnect = true;
                this.isConnected = false;
                
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
                this.reconnectAttempts = 0;
                this.reconnectDelay = 1000;
                
                if (this.pc) {
                    try { this.pc.close(); } catch (e) {}
                    this.pc = null;
                }
                if (this.statsInterval) { clearInterval(this.statsInterval); this.statsInterval = null; }
                try {
                    this.video.srcObject = null;
                    this.video.src = '';
                    this.video.load();
                } catch (e) {}
                this.updateStatus('已断开连接');
                window._lastBytes = 0;
                if (this.isFullscreen) this.toggleFullscreen();
            }

            async connectStream(url, proto) {
                this.disconnect();
                this.isManualDisconnect = false;
                this.currentUrl = url;
                this.currentProto = proto;
                this.updateStatus('正在连接...');

                // HLS playback
                if (proto === 'hls') {
                    try {
                        this.video.src = url;
                        this.video.load();
                        await this.video.play();
                        this.updateStatus('HLS连接成功 · 正在播放');
                        this._startHLSStats();
                    } catch (e) {
                        console.error('HLS连接失败', e);
                        this.updateStatus(`HLS连接失败: ${e.message}`);
                    }
                    return;
                }

                // WebRTC playback
                try {
                    this.pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                    this.pc.addTransceiver('video', { direction: 'recvonly' });
                    this.pc.addTransceiver('audio', { direction: 'recvonly' });

                    this.pc.ontrack = (e) => {
                        try { this.video.srcObject = e.streams[0]; } catch (err) {}
                        this.updateStatus('连接成功 · 正在接收视频');
                    };

                    this.pc.oniceconnectionstatechange = () => {
                        if (this.pc) {
                            const st = this.pc.iceConnectionState;
                            console.log(`ICE状态: ${st}`);
                            if (st === 'connected' || st === 'completed') {
                                this.isConnected = true;
                                this.reconnectAttempts = 0;
                                this.reconnectDelay = 1000;
                            } else if (st === 'failed') {
                                this.updateStatus('ICE连接失败，准备重连...');
                                this._attemptReconnect();
                            } else if (st === 'disconnected') {
                                this.updateStatus('ICE连接断开，等待恢复...');
                                this._waitForIceRecovery();
                            }
                        }
                    };

                    const offer = await this.pc.createOffer();
                    await this.pc.setLocalDescription(offer);

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/sdp' },
                        body: offer.sdp
                    });

                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const answer = await response.text();
                    await this.pc.setRemoteDescription({ type: 'answer', sdp: answer });

                    this._startStats();
                } catch (e) {
                    console.error('连接失败', e);
                    this.updateStatus(`连接失败: ${e.message}`);
                    this.disconnect();
                }
            }

            _startStats() {
                if (this.statsInterval) clearInterval(this.statsInterval);
                this.statsInterval = setInterval(async () => {
                    if (!this.pc || this.pc.connectionState !== 'connected') return;
                    try {
                        const stats = await this.pc.getStats();
                        let fps = 0, bitrate = 0, rtt = 0, loss = 0;
                        stats.forEach(r => {
                            if (r.type === 'inbound-rtp' && r.kind === 'video') {
                                if (r.framesPerSecond) fps = r.framesPerSecond;
                                if (r.bytesReceived && r.timestamp) {
                                    if (window._lastBytes && window._lastTime) {
                                        const dt = (r.timestamp - window._lastTime) / 1000;
                                        bitrate = Math.round(((r.bytesReceived - window._lastBytes) * 8) / dt / 1000);
                                    }
                                    window._lastBytes = r.bytesReceived;
                                    window._lastTime = r.timestamp;
                                }
                            }
                            if (r.type === 'candidate-pair' && r.state === 'succeeded') {
                                if (r.currentRoundTripTime) rtt = Math.round(r.currentRoundTripTime * 1000);
                            }
                            if (r.type === 'inbound-rtp' && r.kind === 'video' && r.packetsLost !== undefined) {
                                const lost = r.packetsLost || 0;
                                const total = (r.packetsReceived || 0) + lost;
                                if (total > 0) loss = Math.round((lost / total) * 100);
                            }
                        });
                        this.updateStatus(`WebRTC · ${bitrate}kbps · ${fps}fps · RTT:${rtt}ms · 丢包:${loss}%`);
                    } catch (e) {}
                }, 1000);
            }

            _waitForIceRecovery() {
                if (this.isManualDisconnect) return;
                
                let checkCount = 0;
                const maxChecks = 10;
                
                const checkInterval = setInterval(() => {
                    if (this.isManualDisconnect || !this.pc) {
                        clearInterval(checkInterval);
                        return;
                    }
                    
                    const state = this.pc.iceConnectionState;
                    if (state === 'connected' || state === 'completed') {
                        clearInterval(checkInterval);
                        this.updateStatus('ICE连接已恢复');
                        return;
                    }
                    
                    checkCount++;
                    if (checkCount >= maxChecks || state === 'failed') {
                        clearInterval(checkInterval);
                        this.updateStatus('ICE恢复失败，准备重连...');
                        this._attemptReconnect();
                    }
                }, 500);
            }

            _attemptReconnect() {
                if (this.isManualDisconnect) {
                    console.log('用户主动断开，不进行重连');
                    return;
                }
                
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    this.updateStatus(`重连失败，已达最大重试次数(${this.maxReconnectAttempts})`);
                    console.log('已达最大重连次数');
                    return;
                }
                
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                }
                
                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), this.maxReconnectDelay);
                
                this.updateStatus(`第${this.reconnectAttempts}次重连，${Math.round(delay/1000)}秒后尝试...`);
                console.log(`第${this.reconnectAttempts}次重连，延迟${delay}ms`);
                
                this.reconnectTimer = setTimeout(async () => {
                    if (this.isManualDisconnect) return;
                    
                    if (!this.currentUrl) {
                        this.updateStatus('无法重连：没有有效的URL');
                        return;
                    }
                    
                    try {
                        await this._doReconnect();
                    } catch (e) {
                        console.error('重连失败:', e);
                        this._attemptReconnect();
                    }
                }, delay);
            }

            async _doReconnect() {
                this._cleanupPeerConnection();
                
                this.pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                this.pc.addTransceiver('video', { direction: 'recvonly' });
                this.pc.addTransceiver('audio', { direction: 'recvonly' });

                this.pc.ontrack = (e) => {
                    try { this.video.srcObject = e.streams[0]; } catch (err) {}
                    this.updateStatus('重连成功 · 正在接收视频');
                    this.reconnectAttempts = 0;
                    this.reconnectDelay = 1000;
                };

                this.pc.oniceconnectionstatechange = () => {
                    if (this.pc) {
                        const st = this.pc.iceConnectionState;
                        console.log(`重连ICE状态: ${st}`);
                        if (st === 'connected' || st === 'completed') {
                            this.isConnected = true;
                            this.reconnectAttempts = 0;
                            this.reconnectDelay = 1000;
                        } else if (st === 'failed') {
                            this.updateStatus('重连ICE失败，准备再次重连...');
                            this._attemptReconnect();
                        } else if (st === 'disconnected') {
                            this.updateStatus('重连后ICE断开，等待恢复...');
                            this._waitForIceRecovery();
                        }
                    }
                };

                const offer = await this.pc.createOffer();
                await this.pc.setLocalDescription(offer);

                const response = await fetch(this.currentUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/sdp' },
                    body: offer.sdp
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const answer = await response.text();
                await this.pc.setRemoteDescription({ type: 'answer', sdp: answer });

                this._startStats();
            }

            _cleanupPeerConnection() {
                if (this.pc) {
                    try {
                        this.pc.ontrack = null;
                        this.pc.oniceconnectionstatechange = null;
                        this.pc.close();
                    } catch (e) {}
                    this.pc = null;
                }
            }

            _startHLSStats() {
                if (this.statsInterval) clearInterval(this.statsInterval);
                this.statsInterval = setInterval(() => {
                    if (this.video.readyState > 0) {
                        const buffered = this.video.buffered;
                        let bufferedTime = 0;
                        if (buffered.length > 0) {
                            bufferedTime = buffered.end(buffered.length - 1) - this.video.currentTime;
                        }
                        this.updateStatus(`HLS播放中 · 缓冲: ${bufferedTime.toFixed(1)}秒`);
                    }
                }, 2000);
            }

            toggleFullscreen() {
                if (!this.isFullscreen) {
                    const overlay = document.createElement('div');
                    overlay.className = 'fullscreen-mode';
                    overlay.id = 'fullscreenContainer';

                    const controls = document.createElement('div');
                    controls.className = 'fullscreen-controls';
                    controls.innerHTML = `<button id="fsDisconnectBtn" type="button">断开</button><button id="fsExitBtn" type="button">退出全屏</button>`;

                    const videoWrapper = document.createElement('div');
                    videoWrapper.style.cssText = 'width:100%;height:100%;display:flex;justify-content:center;align-items:center;';
                    
                    this.video.style.display = '';
                    this.video.style.width = '100%';
                    this.video.style.height = '100%';
                    this.video.style.objectFit = 'contain';
                    videoWrapper.appendChild(this.video);
                    
                    overlay.appendChild(videoWrapper);
                    overlay.appendChild(controls);
                    document.body.appendChild(overlay);

                    document.getElementById('fsDisconnectBtn').addEventListener('click', () => this.disconnect());
                    document.getElementById('fsExitBtn').addEventListener('click', () => this.toggleFullscreen());

                    if (this.fullscreenBtn) this.fullscreenBtn.textContent = '退出全屏';
                    this.isFullscreen = true;

                    this.fullscreenTimeout = setTimeout(() => controls.classList.add('hidden'), 1000);
                    overlay.addEventListener('mousemove', () => {
                        controls.classList.remove('hidden');
                        clearTimeout(this.fullscreenTimeout);
                        this.fullscreenTimeout = setTimeout(() => controls.classList.add('hidden'), 1200);
                    });
                    controls.addEventListener('mouseleave', () => {
                        clearTimeout(this.fullscreenTimeout);
                        this.fullscreenTimeout = setTimeout(() => controls.classList.add('hidden'), 1200);
                    });
                } else {
                    const overlay = document.getElementById('fullscreenContainer');
                    if (overlay) {
                        const videoWrapper = overlay.querySelector('div');
                        if (videoWrapper && this.video.parentElement === videoWrapper) {
                            videoWrapper.removeChild(this.video);
                        }
                        document.body.removeChild(overlay);
                    }
                    if (this.fullscreenTimeout) { clearTimeout(this.fullscreenTimeout); this.fullscreenTimeout = null; }
                    
                    const videoContainer = document.querySelector('.videoContainer');
                    if (videoContainer && this.video.parentElement !== videoContainer) {
                        const statusEl = videoContainer.querySelector('.status');
                        const controlsEl = videoContainer.querySelector('.controls');
                        if (statusEl) {
                            videoContainer.insertBefore(this.video, statusEl);
                        } else if (controlsEl) {
                            videoContainer.insertBefore(this.video, controlsEl);
                        } else {
                            videoContainer.insertBefore(this.video, videoContainer.firstChild);
                        }
                    }
                    this.video.style.width = '';
                    this.video.style.height = '';
                    this.video.style.objectFit = '';
                    this.video.style.display = '';
                    
                    if (this.fullscreenBtn) this.fullscreenBtn.textContent = '网页全屏';
                    this.isFullscreen = false;
                }
            }

            openReconnectModal() {
                const modal = document.getElementById('reconnectModal');
                const inputMaxAttempts = document.getElementById('inputMaxAttempts');
                const inputReconnectDelay = document.getElementById('inputReconnectDelay');
                const inputMaxDelay = document.getElementById('inputMaxDelay');

                inputMaxAttempts.value = this.maxReconnectAttempts;
                inputReconnectDelay.value = this.reconnectDelay;
                inputMaxDelay.value = this.maxReconnectDelay;

                modal.classList.add('active');
            }

            closeReconnectModal() {
                const modal = document.getElementById('reconnectModal');
                modal.classList.remove('active');
            }

            saveReconnectConfig() {
                const inputMaxAttempts = document.getElementById('inputMaxAttempts');
                const inputReconnectDelay = document.getElementById('inputReconnectDelay');
                const inputMaxDelay = document.getElementById('inputMaxDelay');

                this.maxReconnectAttempts = parseInt(inputMaxAttempts.value) || 5;
                this.reconnectDelay = parseInt(inputReconnectDelay.value) || 1000;
                this.maxReconnectDelay = parseInt(inputMaxDelay.value) || 30000;

                console.log(`重连配置已更新: 最大次数=${this.maxReconnectAttempts}, 初始延迟=${this.reconnectDelay}ms, 最大延迟=${this.maxReconnectDelay}ms`);
                this.closeReconnectModal();
            }

            updateStatus(text) { if (this.statusEl) this.statusEl.innerText = text; }
        }

        window.player = new JiBaJiBaPlayer();
    </script>

    <div class="modal-overlay" id="reconnectModal">
        <div class="modal-box">
            <div class="modal-title">
                <span>自动重连配置</span>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-row">
                <label class="modal-label">最大重连次数</label>
                <input type="number" class="modal-input" id="inputMaxAttempts" min="1" max="20" value="5">
                <span class="modal-hint">次</span>
            </div>
            <div class="modal-row">
                <label class="modal-label">初始重连延迟</label>
                <input type="number" class="modal-input" id="inputReconnectDelay" min="500" max="10000" step="500" value="1000">
                <span class="modal-hint">毫秒</span>
            </div>
            <div class="modal-row">
                <label class="modal-label">最大重连延迟</label>
                <input type="number" class="modal-input" id="inputMaxDelay" min="5000" max="120000" step="5000" value="30000">
                <span class="modal-hint">毫秒</span>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="modalCancel">取消</button>
                <button class="modal-btn modal-btn-save" id="modalSave">保存</button>
            </div>
        </div>
    </div>
    <script>
        document.getElementById('modalClose').addEventListener('click', () => window.player.closeReconnectModal());
        document.getElementById('modalCancel').addEventListener('click', () => window.player.closeReconnectModal());
        document.getElementById('modalSave').addEventListener('click', () => window.player.saveReconnectConfig());
        document.getElementById('reconnectModal').addEventListener('click', (e) => {
            if (e.target.id === 'reconnectModal') window.player.closeReconnectModal();
        });
    </script>
</body>
</html>